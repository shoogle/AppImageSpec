# AppImage Specification Version 0 (Draft)

This document is a working draft for Version 0. Developers should refer to the [latest version of the Specification](https://github.com/AppImage/AppImageSpec/blob/master/latest.md).

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](http://www.ietf.org/rfc/rfc2119.txt).

The AppImage Specification is licensed under [The MIT License](https://github.com/AppImage/Spec/blob/master/LICENSE).

##### Table of Contents

* [Introduction]
* [Revision History]
* [Definitions]
* [Specification]
    - [General Format]
    - [Runtime Behavior]
        + [Initial Run]
        + [Subsequent Runs]
        + [Every Run]
    - [AppImage Types]
        + [Type 000]
        + [Type 001]
    - [Contents of the image]
        + [The filesystem image]
        + [The AppRun file]
        + [The payload application]
    - [Metadata]
        + [AppStream]
        + [Update Information]
    - [Desktop Integration]

[Introduction]: #introduction "Introduction"
[Revision History]: #revision-history "Revision History"
[Definitions]: #definitions "Definitions"
[Specification]: #specification "Specification"
[General Format]: #general-format "Specification - General Format"
[Runtime Behavior]: #runtime-behavior "Specification - Runtime Behavior"
  [Initial Run]: #initial-run "Specification - Runtime Behavior - Initial Run"
  [Subsequent Runs]: #subsequent-runs "Specification - Runtime Behavior - Subsequent Runs"
  [Every Run]: #every-run "Specification - Runtime Behavior - Every Run"
[AppImage Types]: #appimage-types "Specification - AppImage Types"
  [Type 000]: #type-000 "Specification - Image Format - Type 000"
  [Type 001]: #type-001 "Specification - Image Format - Type 001"
[Contents of the image]: #contents-of-the-image "Specification - Contents of the image"
  [The filesystem image]: #the-filesystem-image "Specification - Contents of the image - The filesystem image"
  [The AppRun file]: #the-apprun-file "Specification - Contents of the image - The AppRun file"
  [The payload application]: #the-payload-application "Specification - Contents of the image - The payload application"
[Metadata]: #metadata "Specification - Metadata"
  [AppStream]: #appstream "Specification - Metadata - AppStream"
  [Update Information]: #update-information "Specification - Metadata - Update Information"
[Desktop Integration]: #desktop-integration "Specification - Desktop Integration"


## Introduction

The AppImage Specification describes [AppImage], a portable format for deploying software applications to Linux-based operating systems. The Specification may be expanded to include other operating systems in the future.

The AppImage format is designed to meet the needs of users and developers alike. The main strengths are:

 - **P**ortabilty - the same file will run on the majority of Linux distributions without requiring installation or root priviledges.
 - **I**ntegrety - AppImages can be obtained straight from the upstream developer with no intermediaries.
 - **E**fficiency - a single, unified format enables fast turnarounds with Linux releases available from Day 1.
 - **S**implicity - *"one app equals one file"*. Libraries and resources are included in the AppImage.

The AppImage format has been over ten years in the making, and AppImages are available now for some of the most popular open source programs. This inititial version of the Specification seeks to formalize the features common to the majority of AppImages in existence today. Future versions of the Specification will impose new requirements.

A key advantage of the AppImage format over other packaging formats is flexibility. AppImages do not require any form of package management system. In addition, many aspects of the Specification are optional and there are few strict requirements. However, it benefits users and developers when software applications behave in a manner that is consistent and predictable, so developers are encouraged to follow all parts of the Specification as closely as possible.


## Revision History

Version | Date | Notes
--- | --- | ---
Draft | 2016-06-15 | Initial draft of the AppImage Specification started


## Definitions

##### AppDir
Application directories [as used in the ROX desktop](http://rox.sourceforge.net/desktop/AppDirs.html), or the extracted contents of an AppImage.

[AppDir]: #appdir "AppDir: Application Directory (as used in the ROX Desktop)"

##### AppImage
###### AppImage (file)
An application executable that has been packaged in the AppImage format. (Examples created [here](https://bintray.com/probono/AppImages) and available [here](https://github.com/probonopd/AppImageKit).)

###### AppImage (format)
The portable packaging format defined in this Specification, which can be used to deploy applications to Linux systems.

[AppImage]: #appimage "AppImage: The packaging format defined in this Specification, or an application packaged in this format"

##### AppImage Standards Version
The version of this Specification with which a particular AppImage complies. (Identified in the [Metadata])

[AppImage Standards Version]: #appimage-standards-version "AppImage Standards Version: The version of this Specification with which a particular AppImage complies. (Identified in the Metadata)"

##### AppImage Type
The representation of an AppImage on disk. Identified by a **Type Byte** (0x00-0xFF) or equivalent **Decimal Type** (000-255).

[AppImage Type]: #appimage-type "AppImage Type: The representation of an AppImage on disk. Identified by a Type Byte (0x00-0xFF) or equivalent 3-digit Decimal Type (000-255)."
[Type Byte]: #appimage-type "Type Byte: A magic byte of range 0x00 to 0xFF that is used to identify the AppImage Type"
[Decimal Type]: #appimage-type "Decimal Type: A 3-digit decimal representation of the Type Byte, ranging from 000-255"

##### AppImageKit
A reference implementation of a tool for building AppImages in compliance with this Specification. (Available [here](https://github.com/probonopd/AppImageKit))

[AppImageKit]: #appimagekit "AppImageKit: A packaging tool for building AppImages"

##### Delta updates
An efficient method of updating software which only downloads the changed part of each file.

[delta updates]: #delta-updates "Delta update: An efficient method of updating software which only downloads the changed part of each file."

##### .desktop file
A Desktop Entry File following the [Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/)

[.desktop file]: #desktop-file ".desktop file: A Desktop Entry File following the Desktop Entry Specificiation"

##### MIME Type
A media type or file format identifier in comliance with [RFC 6838](http://tools.ietf.org/html/rfc6838).

[MIME Type]: #mime-type "MIME Type: A media type or file format identifier"

##### Payload application
The software application contained within an AppImage.

[payload application]: #payload-application "Payload application: The software application contained within an AppImage"

##### Target system(s)
The hardware, software and user environment(s) in which an AppImage is intended to run. In particular, the supported processor architecture(s) and operating system(s) or Linux distribution(s).

[target system]: #target-systems "Target System(s): The system(s) on which an AppImage is intended to run"

##### zsync
A file transfer program that facilitates [delta updates] - <http://zsync.moria.org.uk/paper/>

[zsync]: #zsync "zsync: A file transfer program that facilitates delta updates."


## Specification


### General Format

(The key word "SHOULD" in this section will be replaced with "MUST" in a future version of the Specification.)

An AppImage **SHOULD** present itself to the user as a single executable file which, when distributed:

* has the `.AppImage` file extension
* has the magic bytes `AIx` at offset 8, where `A` and `I` are ASCII characters and `x` is the [Type Byte], **OR**
* has the ASCII sequence `AppImage###` in the first 128 bytes of the file, where `###` is the 3 digit [Decimal Type]
* obeys the following naming convention for official release builds:
    - `AppName-$VERSION-$ARCH.AppImage` (e.g. `Subsurface-4.5.6-x86_64.AppImage`), where:
        + `AppName` is the ordinary name of the [payload application], **NOT** a command line alias
        + `$VERSION` is the version of the [payload application], X.Y.Z [Semantic Version](http://semver.org/) or similar
        + `$ARCH` is the output of the UNIX command `arch` or `uname -m` on the [target system]
    - **OR** `<AppName>-<version>.AppImage` if capable of running on multiple architectures
* clearly distinguishes nightly, development or pre-release builds from official releases. Examples of this:
    - Nightly: `MuseScoreNightly-201602261810-master-a6ec8aa-x86_64.AppImage` (`$DATE-$BRANCH-$COMMIT-$ARCH`)
    - Pre-release: `MuseScore-2.0.0_beta.1-x86_64.AppImage`

Providing that user still has execute permission, the AppImage **SHOULD** continue to function as intended, even if:

* file name or extension are changed
* the file path contains spaces or special characters
* the file is moved or placed on removable media


### Runtime Behavior

#### Initial Run

When a user attempts to run an AppImage for the first time, the AppImage:

* **MUST NOT** require any form of installation other than the granting of execute permission
* **SHOULD** offer to perform installation or [desktop integration] as an optional feature

#### Subsequent Runs

AppImages **MUST NOT** offer to perform installation or [desktop integration] if it has already been done

#### Every Run

Whenever it is executed, an AppImages:

* **MUST NOT** require root or administrator priviledges **UNLESS** the primary purpose of the [payload application] is to perform a task that requires such priviledges
* **MUST** make it clear to the user why root or administrator priviledges are required if such priviledges are required

Executing the AppImage **MUST** result in the launch of the [payload application] **UNLESS**:

* the user explicitly chose not to do so, for example by specifying a pertinent command line option
* it was unsafe or unable to do so, in which case the user **SHOULD** be given a reason

The AppImage **SHOULD** pass on any command line arguments and environment variables to the [payload application] either directly or indirectly (i.e., by invoking other helper binaries or scripts which, in turn, launch the [payload application]) unless the argument or environment variable was intended for the helper executable and not the [payload application]

It **MUST** be safe to have multiple AppImage and/or non-AppImage versions of the [payload application] on the same machine. In particular, the AppImage or [payload application]:

* **SHOULD NOT** cause conflicts if run alongside another instance of itself or any version of the [payload application]
* **MUST** refuse to run if another instance is already running and conflicts would otherwise occur

**If** the AppImage file is an archive, ISO image, or other container format and it contains files that need to be outside the AppImage at runtime, **THEN** the AppImage:

* **MUST**, on being executed, create a temporary directory in `/tmp' or another suitable location on the user's hard drive the contents of which are not persistent when the computer is rebooted
* **MUST** give the tempory directory a name that includes characters which are generated randomly at runtime
* **MUST** extract its contents to this temporary directory
* **MUST NOT** give any scope (user/group/other) write permission to any files or directories inside the tempory directory
* **MUST** delete the temporary directory once it has finished executing


### AppImage Types

**IMPORTANT** - AppImage Types **DO NOT** correspond to particular versions of the AppImage Specification!

The AppImage Type determines how an AppImage is represented on disk. Types can be identified by:

* A **[Type Byte]** in the range `0x00` to `0xFF`
* A corresponding 3 digit **[Decimal Type]** in the range 000 to 255

Currently only two types are defined, but there may be more Types in the future. A 3rd party program that interacts with AppImages should use the AppImage Type to determine how to access the AppImage [Metadata]. The Metadata contains the [AppImage Standards Version], which corresponds to the version of this Specification with which the AppImage complies. The AppImage Type and Standards Version together determine how the program may interact with the AppImage.

#### Type 000
**Type Byte: `0x00`**

The "other" type. These files look and behave like AppImages but are implemented differently internally. They **MUST** conform to all parts of the Specification, but because they do not fall into a defined Type they are not guaranteed to work with 3rd party programs that rely on a particular internal structure.

#### Type 001
**Type Byte: `0x01`**

An [AppImage] which conforms to the type 1 image format:

* **MUST** be an [ISO 9660](http://www.ecma-international.org/publications/standards/Ecma-119.htm) file
* **MUST** use [Rock Ridge](http://www.ymi.com/ymi/sites/default/files/pdf/Rockridge.pdf) extensions
* **MAY** use [Joliet](http://support.microsoft.com/kb/125630) extensions
* **SHOULD** use [zisofs](http://libburnia-project.org/wiki/zisofs) compression
* **MUST** be a vaild [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) executable 
* **MUST**, when executed, mount the [AppImage] and execute the executable file `AppRun` contained in the root of the ISO 9660 filesystem
* **SHOULD** not be encapsulated in another archive/container format during download or when stored
* **MAY** embed [update information] in the ISO 9660 Volume Descriptor field (offset 33651). If the information in this location is not in one of the known [update information] formats, then it **SHOULD** be empty and/or be ignored


### Contents of the image

#### The filesystem image:

* Is an [AppDir]
* **MUST** contain a file named `AppRun` in its root directory
* **SHOULD** contain a [payload application] that is ultimately executed when the [AppImage] is executed
* **SHOULD** contain exactly one `$APPNAME.desktop` file in its root directory with `$APPNAME` being the name of the [payload application]
* **MAY** contain an `$APPNAME.svg` or `$APPNAME.png` file in its root directory with `$APPNAME` being the name of the [payload application] as set in the `Icon=` key of the `$APPNAME.desktop` file. If present, this icon **SHOULD** be given preference as the icon being used to represent the [AppImage]. The icon **SHOULD** be an SVG or PNG with 256x256 or 512*512 pixels
* **SHOULD** contain a `.DirIcon` file as per the [AppDir] specification

#### The `AppRun` file:

* **MUST** be executable and, when executed, launch the [payload application] either directly or indirectly (i.e., by invoking other helper binaries or scripts which, in turn, launch the [payload application])
* **MAY** be an ELF binary or an interpreted script
* If it is an ELF binary, it **SHOULD** have as few runtime dependencies as possible
* If it is an interpreted script, it **SHOULD** be written in a language in which an interpreter can be assumed to be available on every [target system]
* **SHOULD** pass any arguments and environment variables passed to it to the [payload application] either directly or indirectly (i.e., by invoking other helper binaries or scripts which, in turn, launch the [payload application]) if it is not explicitly deemed useful otherwise
* **MAY** `cd` to a directory inside the [AppImage] at runtime before executing the [payload application], commonly `./usr/` 

#### The [payload application]:

* **MAY** be an ELF binary or an interpreted script
* If it is an ELF binary, it **SHOULD** have as few dynamic library dependencies as possible and each dynamic library dependency **MUST** be included in the [AppImage] *IF* it cannot be assumed to be part of every [target system] in a recent enough version
* If it is an interpreted script, it **SHOULD** be written in a language in which an interpreter can be assumed to be available on every [target system], otherwise the interpreter **MUST** be included in the [AppImage]
* It is **RECOMMENDED** that the [payload application] and its dependencies are located in a `$PREFIX` directory tree inside the [AppDir] with `$PREFIX` commonly being `./usr/`; it is **RECOMMENDED** that the `$PREFIX` directory tree inside the [AppDir] follows the [File System Hierarchy conventions for `/usr`](http://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch04.html)


### Metadata

Section to be expanded; additional metadata is being discussed on <https://github.com/probonopd/AppImageKit/issues/59>

#### AppStream

An [AppImage] **SHOULD** ship AppStream metadata in `usr/share/metainfo/$ID.xml` with `$ID` being the AppStream ID. Shipping AppStream information enables the [AppImage] to be discoverable in application centers and/or application directory websites. If it does, then it **MUST** follow the AppStream [guidelines for applications](https://github.com/hughsie/appstream-glib#guidelines-for-applications).

#### Update information

An [AppImage] **MAY** have [update information] embedded for exactly one transport mechanism. The location in which this information is stored is defined by the [image format](#image-format). Currently two transport mechanisms are available, but only one can be used for each given [AppImage]:

 * [zsync]
 * bintray-zsync
 
##### zsync

The __[zsync]__ transport requires a HTTP server that can handle HTTP range requests. Its [update information] is in the form

```
zsync|http://server.domain/path/Application-latest-x86_64.AppImage.zsync
```

If an [AppImage] has [update information] embedded for this transport mechanism, then the following fields **MUST** be used; separated by a "|" character:

Field | Type | Example | Comments
----------- | ------ | -------- | --------
Transport mechanism | String | `zsync` | [zsync] file and [AppImage] **MUST** be stored on  [compatible](http://zsync.moria.org.uk/server-issues) HTTP server
zsync file URL | String | `http://server.domain/path/Application-latest-x86_64.AppImage.zsync` | URL to the `.zsync` file (URL **MUST NOT** change from version to version)

For an overview about [zsync] and how to create `.zsync` files, see [http://zsync.moria.org.uk/](http://zsync.moria.org.uk/).

##### bintray-zsync

The __bintray-zsync__ transport extends the [zsync] transport in that it uses version information from [Bintray](http://bintray.com/). Its [update information] is in the form

```
bintray-zsync|probono|AppImages|Subsurface|Subsurface-_latestVersion-x86_64.AppImage.zsync
```

If an [AppImage] has [update information] embedded for this transport mechanism, then the following fields **MUST** be used; separated by a "|" character:

Field | Type | Example | Comments
----------- | ------ | -------- | --------
Transport mechanism | String | `bintray-zsync` | [zsync] file and [AppImage] **MUST** be stored on Bintray
Bintray username | String | `probono` | Name of the user or organization of the account where the [zsync] file and [AppImage] are stored
Bintray repository | String | `AppImages` | Name of the repository in which the [zsync] file and [AppImage] are stored
Bintray package name | String | `Subsurface` | Name of the [Bintray package](https://bintray.com/docs/usermanual/uploads/uploads_creatinganewpackage.html) in which the [zsync] file and [AppImage] are stored
Bintray zsync path | String | `Subsurface-_latestVersion-x86_64.AppImage.zsync` | Path where the [zsync] file is stored on Bintray (**MUST NOT** change from version to version). Note the use of the Bintray feature `_latestVersion` to facilitate this

### Desktop integration

The software inside the [AppImage] **MAY** integrate into the desktop environment (e.g., by installing a [.desktop file] into the host system) on the user's behalf. However if it does so, it *SHOULD* ensure to get the explicit permission of the user, e.g., by asking for permission in a GUI window, or by reacting to a command line argument.

The software inside the [AppImage] **SHOULD NOT** attempt to do desktop integration if at least one of the following conditions are met:

* A file `$HOME/.local/share/appimagekit/no_desktopintegration` exists on the [target system]
* A file `/usr/share/appimagekit/no_desktopintegration` exists on the [target system]
* A file `/etc/appimagekit/no_desktopintegration` exists on the [target system]
* A process named `appimaged` is running on the system
* The environment variable `$DESKTOPINTEGRATION` is not empty
